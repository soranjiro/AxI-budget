# name: Deploy to Production

# on:
#   push:
#     branches: [ main ]
#   workflow_dispatch:
#     inputs:
#       frontend-artifact:
#         description: 'Frontend build artifact name (optional)'
#         required: false
#         type: string
#       backend-artifact:
#         description: 'Backend Lambda artifact name (optional)'
#         required: false
#         type: string
#       skip-tests:
#         description: 'Skip running tests (use existing artifacts)'
#         required: false
#         type: boolean
#         default: false

# env:
#   AWS_REGION: ap-northeast-1
#   ENVIRONMENT: prod

# jobs:
#   # Run tests if not skipped and no artifacts provided
#   test-frontend:
#     if: ${{ !inputs.skip-tests && !inputs.frontend-artifact }}
#     uses: ./.github/workflows/test-frontend.yml

#   test-backend:
#     if: ${{ !inputs.skip-tests && !inputs.backend-artifact }}
#     uses: ./.github/workflows/test-backend.yml

#   test-e2e:
#     if: ${{ !inputs.skip-tests }}
#     needs: [test-frontend]
#     uses: ./.github/workflows/test-e2e.yml
#     with:
#       frontend-artifact-name: ${{ needs.test-frontend.outputs.build-artifact-name }}

#   # Deploy to production
#   deploy-production:
#     runs-on: ubuntu-latest
#     needs: [test-frontend, test-backend, test-e2e]
#     if: always() && !failure() && !cancelled()
#     environment:
#       name: production
#       url: https://axi-budget.example.com

#     steps:
#     - name: Checkout code
#       uses: actions/checkout@v4

#     - name: Configure AWS credentials
#       uses: aws-actions/configure-aws-credentials@v4
#       with:
#         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
#         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
#         aws-region: ${{ env.AWS_REGION }}

#     - name: Setup Terraform
#       uses: hashicorp/setup-terraform@v3
#       with:
#         terraform_version: 1.5.0

#     - name: Deploy infrastructure
#       working-directory: ./infrastructure
#       run: |
#         terraform init
#         terraform workspace select ${{ env.ENVIRONMENT }} || terraform workspace new ${{ env.ENVIRONMENT }}
#         terraform plan -var="environment=${{ env.ENVIRONMENT }}" -var="enable_deletion_protection=true"
#         terraform apply -auto-approve -var="environment=${{ env.ENVIRONMENT }}" -var="enable_deletion_protection=true"

#     - name: Download Lambda artifact
#       uses: actions/download-artifact@v4
#       with:
#         name: ${{ inputs.backend-artifact || format('lambda-deployment-{0}', github.sha) }}
#         path: ./

#     - name: Update Lambda function
#       run: |
#         aws lambda update-function-code \
#           --function-name axi-budget-${{ env.ENVIRONMENT }}-api \
#           --zip-file fileb://lambda-deployment.zip

#     - name: Wait for Lambda update
#       run: |
#         aws lambda wait function-updated \
#           --function-name axi-budget-${{ env.ENVIRONMENT }}-api

#     - name: Download frontend build
#       uses: actions/download-artifact@v4
#       with:
#         name: ${{ inputs.frontend-artifact || format('frontend-build-{0}', github.sha) }}
#         path: frontend-build/

#     - name: Deploy frontend to S3
#       run: |
#         BUCKET_NAME=$(terraform -chdir=infrastructure output -raw s3_bucket_name)
#         echo "Deploying to S3 bucket: $BUCKET_NAME"

#         # Deploy with proper cache headers
#         aws s3 sync frontend-build/ s3://$BUCKET_NAME/ --delete --cache-control "public, max-age=31536000" --exclude "*.html"
#         aws s3 sync frontend-build/ s3://$BUCKET_NAME/ --delete --cache-control "public, max-age=0" --exclude "*" --include "*.html"

#     - name: Invalidate CloudFront cache
#       run: |
#         DISTRIBUTION_ID=$(terraform -chdir=infrastructure output -raw cloudfront_distribution_id)
#         echo "Invalidating CloudFront distribution: $DISTRIBUTION_ID"

#         aws cloudfront create-invalidation \
#           --distribution-id $DISTRIBUTION_ID \
#           --paths "/*"

#     - name: Run production health check
#       run: |
#         DOMAIN_NAME=$(terraform -chdir=infrastructure output -raw domain_name)
#         echo "Running health check on: https://$DOMAIN_NAME"

#         # Wait for deployment to propagate
#         sleep 60

#         # Comprehensive health check
#         for i in {1..5}; do
#           echo "Health check attempt $i/5..."
#           if curl -f -s -o /dev/null -w "%{http_code}" https://$DOMAIN_NAME | grep -q "200"; then
#             echo "‚úÖ Production site is accessible"
#             break
#           fi
#           if [ $i -eq 5 ]; then
#             echo "‚ùå Production health check failed after 5 attempts"
#             exit 1
#           fi
#           sleep 30
#         done

#     - name: Run smoke tests
#       run: |
#         DOMAIN_NAME=$(terraform -chdir=infrastructure output -raw domain_name)

#         # Check critical paths
#         echo "Testing critical application paths..."

#         # Test main app
#         curl -f -s "https://$DOMAIN_NAME" > /dev/null || exit 1

#         # Test PWA manifest
#         curl -f -s "https://$DOMAIN_NAME/manifest.webmanifest" > /dev/null || exit 1

#         # Test service worker
#         curl -f -s "https://$DOMAIN_NAME/sw.js" > /dev/null || exit 1

#         echo "‚úÖ All smoke tests passed!"

#     - name: Create deployment tag
#       run: |
#         git config --local user.email "action@github.com"
#         git config --local user.name "GitHub Action"

#         TAG_NAME="prod-deploy-$(date +'%Y%m%d-%H%M%S')"
#         git tag -a "$TAG_NAME" -m "Production deployment on $(date)"
#         git push origin "$TAG_NAME"

#     - name: Notify deployment status
#       if: always()
#       run: |
#         if [ "${{ job.status }}" == "success" ]; then
#           echo "üéâ Production deployment completed successfully!"
#           echo "üîó Application URL: https://$(terraform -chdir=infrastructure output -raw domain_name)"
#         else
#           echo "‚ùå Production deployment failed!"
#         fi

#     - name: Rollback on failure
#       if: failure()
#       run: |
#         echo "üîÑ Starting rollback procedure..."

#         # Get previous successful deployment
#         PREV_TAG=$(git tag -l "prod-deploy-*" | sort -V | tail -2 | head -1)

#         if [ -n "$PREV_TAG" ]; then
#           echo "Rolling back to: $PREV_TAG"
#           # Implement rollback logic here
#           # This could involve reverting to previous Lambda version and S3 content
#         else
#           echo "‚ö†Ô∏è No previous deployment found for rollback"
#         fi
